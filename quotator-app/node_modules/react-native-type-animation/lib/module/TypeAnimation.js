import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { Animated, InteractionManager, Text } from 'react-native';
import { countMatchingCharacters, delay, repeatFunctionNTimes } from './utilis/helper_functions';

/**
 * Props for the blinking cursor component.
 */

/**
 * A blinking cursor component that animates its opacity.
 */
const Cursor = _ref => {
  let {
    blinkSpeed = 500,
    cursorStyle,
    style
  } = _ref;
  const opacity = useRef(new Animated.Value(0)).current;
  useEffect(() => {
    Animated.loop(Animated.sequence([Animated.timing(opacity, {
      toValue: 1,
      duration: 0,
      useNativeDriver: false,
      isInteraction: false
    }), Animated.delay(blinkSpeed), Animated.timing(opacity, {
      toValue: 0,
      duration: 0,
      useNativeDriver: false,
      isInteraction: false
    }), Animated.delay(blinkSpeed)])).start();
  }, [blinkSpeed, opacity]);
  return /*#__PURE__*/React.createElement(Animated.Text, {
    style: {
      opacity,
      ...style,
      ...cursorStyle
    }
  }, "|");
};

/**
 * Props for the typewriter animation component.
 */

/**
 * Typewriter animation component that displays text with typing animations.
 */
const TypeAnimation = _ref2 => {
  let {
    sequence,
    delayBetweenSequence = 100,
    splitter = str => str.split(/(?=\S)/),
    repeat = 1,
    loop,
    blinkSpeed,
    style,
    cursorStyle,
    cursor = true,
    direction = 'front',
    preRenderText = '',
    initialDelay = 0,
    onCharTyped,
    onCharDeleted,
    typeSpeed = 100,
    deletionSpeed = 100
  } = _ref2;
  const [text, setText] = useState(preRenderText);
  let currentText = preRenderText;

  /**
   * Type a sequence of letters with a specified speed.
   * @param textToType - The text to type.
   * @param speed - The typing speed.
   */
  const typeLetters = function (textToType) {
    let speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : typeSpeed;
    const isFront = direction === 'front';
    const textArray = splitter(textToType);
    if (!isFront) {
      textArray.reverse();
    }
    return new Promise(async resolve => {
      for (const character of textArray) {
        if (isFront) {
          setText(currText => {
            const word = `${currText}${character ?? ''}`;
            if (character) {
              const data = {
                character,
                currentText: word
              };
              if (onCharTyped) {
                onCharTyped(data);
              }
            }
            return word;
          });
        } else {
          setText(currText => {
            const word = `${character ?? ""}${currText}`;
            if (character) {
              const data = {
                character,
                currentText: word
              };
              if (onCharTyped) {
                onCharTyped(data);
              }
            }
            return word;
          });
        }
        await delay(speed);
      }
      resolve();
    });
  };

  /**
   * Delete a specified number of letters with a specified speed.
   * @param count - The number of letters to delete.
   * @param speed - The deletion speed.
   */
  const deleteLetters = function (count) {
    let speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : deletionSpeed;
    return new Promise(resolve => {
      let i = 0;
      const interval = setInterval(() => {
        if (i >= count) {
          clearInterval(interval);
          resolve();
        } else {
          if (direction === 'front') {
            setText(currtext => {
              const word = `${currtext.substring(0, currtext.length - 1)}`;
              const character = currtext[currtext.length - 1];
              if (character) {
                const data = {
                  character,
                  currentText: word
                };
                if (onCharDeleted) {
                  onCharDeleted(data);
                }
              }
              return word;
            });
          } else {
            setText(currtext => {
              const word = `${currtext.substring(1, currtext.length)}`;
              const character = currtext[0];
              if (character) {
                const data = {
                  character,
                  currentText: word
                };
                if (onCharDeleted) {
                  onCharDeleted(data);
                }
              }
              return word;
            });
          }
        }
        i++;
      }, speed);
    });
  };

  /**
   * Run the typing and deletion sequence based on the provided data.
   */
  const runSequence = async () => {
    for (const data of sequence) {
      if (data !== null && data !== void 0 && data.action) {
        data.action();
        if (data !== null && data !== void 0 && data.delayBetweenSequence) {
          await delay((data === null || data === void 0 ? void 0 : data.delayBetweenSequence) ?? delayBetweenSequence);
        }
      } else if (currentText) {
        var _data$text5, _data$text6, _data$text7, _data$text8;
        const count = countMatchingCharacters(currentText, (data === null || data === void 0 ? void 0 : data.text) ?? '', direction);
        // console.log('count', count, currentText);
        const del = (data === null || data === void 0 ? void 0 : data.deleteCount) ?? currentText.length - count;
        await deleteLetters(del, data === null || data === void 0 ? void 0 : data.deletionSpeed);
        if (direction === 'front') {
          var _data$text, _data$text2;
          currentText = currentText.substring(0, currentText.length - del) + (data === null || data === void 0 || (_data$text = data.text) === null || _data$text === void 0 ? void 0 : _data$text.substring(count, data === null || data === void 0 || (_data$text2 = data.text) === null || _data$text2 === void 0 ? void 0 : _data$text2.length));
        } else {
          var _data$text3, _data$text4;
          currentText = (data === null || data === void 0 || (_data$text3 = data.text) === null || _data$text3 === void 0 ? void 0 : _data$text3.substring(0, (data === null || data === void 0 || (_data$text4 = data.text) === null || _data$text4 === void 0 ? void 0 : _data$text4.length) - count)) + currentText.substring(del, currentText.length);
        }
        await typeLetters(direction === 'front' ? data === null || data === void 0 || (_data$text5 = data.text) === null || _data$text5 === void 0 ? void 0 : _data$text5.substring(count, data === null || data === void 0 || (_data$text6 = data.text) === null || _data$text6 === void 0 ? void 0 : _data$text6.length) : data === null || data === void 0 || (_data$text7 = data.text) === null || _data$text7 === void 0 ? void 0 : _data$text7.substring(0, (data === null || data === void 0 || (_data$text8 = data.text) === null || _data$text8 === void 0 ? void 0 : _data$text8.length) - count), data === null || data === void 0 ? void 0 : data.typeSpeed);
        await delay((data === null || data === void 0 ? void 0 : data.delayBetweenSequence) ?? delayBetweenSequence);
      } else {
        currentText = data === null || data === void 0 ? void 0 : data.text;
        await typeLetters(data === null || data === void 0 ? void 0 : data.text, data === null || data === void 0 ? void 0 : data.typeSpeed);
        await delay((data === null || data === void 0 ? void 0 : data.delayBetweenSequence) ?? delayBetweenSequence);
      }
    }
  };
  const firstFunction = useCallback(() => {
    if (loop) {
      const run = async () => {
        await runSequence();
        run();
      };
      run();
    } else {
      repeatFunctionNTimes(runSequence, repeat);
    }
    /* eslint-disable react-hooks/exhaustive-deps */
  }, []);
  useEffect(() => {
    const handle = InteractionManager.createInteractionHandle();
    if (initialDelay) {
      setTimeout(() => {
        firstFunction();
      }, initialDelay);
    } else {
      firstFunction();
    }
    return () => InteractionManager.clearInteractionHandle(handle);
  }, []);
  const cursorComponent = useMemo(() => {
    return cursor ? /*#__PURE__*/React.createElement(Cursor, {
      blinkSpeed: blinkSpeed,
      style: style,
      cursorStyle: cursorStyle
    }) : null;
  }, [cursor, blinkSpeed, style, cursorStyle]);
  return /*#__PURE__*/React.createElement(Text, {
    style: {
      ...style
    }
  }, direction === 'back' && cursorComponent, text, direction === 'front' && cursorComponent);
};
export default TypeAnimation;
//# sourceMappingURL=TypeAnimation.js.map