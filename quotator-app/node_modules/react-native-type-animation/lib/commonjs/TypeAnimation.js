"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _helper_functions = require("./utilis/helper_functions");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * Props for the blinking cursor component.
 */

/**
 * A blinking cursor component that animates its opacity.
 */
const Cursor = _ref => {
  let {
    blinkSpeed = 500,
    cursorStyle,
    style
  } = _ref;
  const opacity = (0, _react.useRef)(new _reactNative.Animated.Value(0)).current;
  (0, _react.useEffect)(() => {
    _reactNative.Animated.loop(_reactNative.Animated.sequence([_reactNative.Animated.timing(opacity, {
      toValue: 1,
      duration: 0,
      useNativeDriver: false,
      isInteraction: false
    }), _reactNative.Animated.delay(blinkSpeed), _reactNative.Animated.timing(opacity, {
      toValue: 0,
      duration: 0,
      useNativeDriver: false,
      isInteraction: false
    }), _reactNative.Animated.delay(blinkSpeed)])).start();
  }, [blinkSpeed, opacity]);
  return /*#__PURE__*/_react.default.createElement(_reactNative.Animated.Text, {
    style: {
      opacity,
      ...style,
      ...cursorStyle
    }
  }, "|");
};

/**
 * Props for the typewriter animation component.
 */

/**
 * Typewriter animation component that displays text with typing animations.
 */
const TypeAnimation = _ref2 => {
  let {
    sequence,
    delayBetweenSequence = 100,
    splitter = str => str.split(/(?=\S)/),
    repeat = 1,
    loop,
    blinkSpeed,
    style,
    cursorStyle,
    cursor = true,
    direction = 'front',
    preRenderText = '',
    initialDelay = 0,
    onCharTyped,
    onCharDeleted,
    typeSpeed = 100,
    deletionSpeed = 100
  } = _ref2;
  const [text, setText] = (0, _react.useState)(preRenderText);
  let currentText = preRenderText;

  /**
   * Type a sequence of letters with a specified speed.
   * @param textToType - The text to type.
   * @param speed - The typing speed.
   */
  const typeLetters = function (textToType) {
    let speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : typeSpeed;
    const isFront = direction === 'front';
    const textArray = splitter(textToType);
    if (!isFront) {
      textArray.reverse();
    }
    return new Promise(async resolve => {
      for (const character of textArray) {
        if (isFront) {
          setText(currText => {
            const word = `${currText}${character ?? ''}`;
            if (character) {
              const data = {
                character,
                currentText: word
              };
              if (onCharTyped) {
                onCharTyped(data);
              }
            }
            return word;
          });
        } else {
          setText(currText => {
            const word = `${character ?? ""}${currText}`;
            if (character) {
              const data = {
                character,
                currentText: word
              };
              if (onCharTyped) {
                onCharTyped(data);
              }
            }
            return word;
          });
        }
        await (0, _helper_functions.delay)(speed);
      }
      resolve();
    });
  };

  /**
   * Delete a specified number of letters with a specified speed.
   * @param count - The number of letters to delete.
   * @param speed - The deletion speed.
   */
  const deleteLetters = function (count) {
    let speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : deletionSpeed;
    return new Promise(resolve => {
      let i = 0;
      const interval = setInterval(() => {
        if (i >= count) {
          clearInterval(interval);
          resolve();
        } else {
          if (direction === 'front') {
            setText(currtext => {
              const word = `${currtext.substring(0, currtext.length - 1)}`;
              const character = currtext[currtext.length - 1];
              if (character) {
                const data = {
                  character,
                  currentText: word
                };
                if (onCharDeleted) {
                  onCharDeleted(data);
                }
              }
              return word;
            });
          } else {
            setText(currtext => {
              const word = `${currtext.substring(1, currtext.length)}`;
              const character = currtext[0];
              if (character) {
                const data = {
                  character,
                  currentText: word
                };
                if (onCharDeleted) {
                  onCharDeleted(data);
                }
              }
              return word;
            });
          }
        }
        i++;
      }, speed);
    });
  };

  /**
   * Run the typing and deletion sequence based on the provided data.
   */
  const runSequence = async () => {
    for (const data of sequence) {
      if (data !== null && data !== void 0 && data.action) {
        data.action();
        if (data !== null && data !== void 0 && data.delayBetweenSequence) {
          await (0, _helper_functions.delay)((data === null || data === void 0 ? void 0 : data.delayBetweenSequence) ?? delayBetweenSequence);
        }
      } else if (currentText) {
        var _data$text5, _data$text6, _data$text7, _data$text8;
        const count = (0, _helper_functions.countMatchingCharacters)(currentText, (data === null || data === void 0 ? void 0 : data.text) ?? '', direction);
        // console.log('count', count, currentText);
        const del = (data === null || data === void 0 ? void 0 : data.deleteCount) ?? currentText.length - count;
        await deleteLetters(del, data === null || data === void 0 ? void 0 : data.deletionSpeed);
        if (direction === 'front') {
          var _data$text, _data$text2;
          currentText = currentText.substring(0, currentText.length - del) + (data === null || data === void 0 || (_data$text = data.text) === null || _data$text === void 0 ? void 0 : _data$text.substring(count, data === null || data === void 0 || (_data$text2 = data.text) === null || _data$text2 === void 0 ? void 0 : _data$text2.length));
        } else {
          var _data$text3, _data$text4;
          currentText = (data === null || data === void 0 || (_data$text3 = data.text) === null || _data$text3 === void 0 ? void 0 : _data$text3.substring(0, (data === null || data === void 0 || (_data$text4 = data.text) === null || _data$text4 === void 0 ? void 0 : _data$text4.length) - count)) + currentText.substring(del, currentText.length);
        }
        await typeLetters(direction === 'front' ? data === null || data === void 0 || (_data$text5 = data.text) === null || _data$text5 === void 0 ? void 0 : _data$text5.substring(count, data === null || data === void 0 || (_data$text6 = data.text) === null || _data$text6 === void 0 ? void 0 : _data$text6.length) : data === null || data === void 0 || (_data$text7 = data.text) === null || _data$text7 === void 0 ? void 0 : _data$text7.substring(0, (data === null || data === void 0 || (_data$text8 = data.text) === null || _data$text8 === void 0 ? void 0 : _data$text8.length) - count), data === null || data === void 0 ? void 0 : data.typeSpeed);
        await (0, _helper_functions.delay)((data === null || data === void 0 ? void 0 : data.delayBetweenSequence) ?? delayBetweenSequence);
      } else {
        currentText = data === null || data === void 0 ? void 0 : data.text;
        await typeLetters(data === null || data === void 0 ? void 0 : data.text, data === null || data === void 0 ? void 0 : data.typeSpeed);
        await (0, _helper_functions.delay)((data === null || data === void 0 ? void 0 : data.delayBetweenSequence) ?? delayBetweenSequence);
      }
    }
  };
  const firstFunction = (0, _react.useCallback)(() => {
    if (loop) {
      const run = async () => {
        await runSequence();
        run();
      };
      run();
    } else {
      (0, _helper_functions.repeatFunctionNTimes)(runSequence, repeat);
    }
    /* eslint-disable react-hooks/exhaustive-deps */
  }, []);
  (0, _react.useEffect)(() => {
    const handle = _reactNative.InteractionManager.createInteractionHandle();
    if (initialDelay) {
      setTimeout(() => {
        firstFunction();
      }, initialDelay);
    } else {
      firstFunction();
    }
    return () => _reactNative.InteractionManager.clearInteractionHandle(handle);
  }, []);
  const cursorComponent = (0, _react.useMemo)(() => {
    return cursor ? /*#__PURE__*/_react.default.createElement(Cursor, {
      blinkSpeed: blinkSpeed,
      style: style,
      cursorStyle: cursorStyle
    }) : null;
  }, [cursor, blinkSpeed, style, cursorStyle]);
  return /*#__PURE__*/_react.default.createElement(_reactNative.Text, {
    style: {
      ...style
    }
  }, direction === 'back' && cursorComponent, text, direction === 'front' && cursorComponent);
};
var _default = exports.default = TypeAnimation;
//# sourceMappingURL=TypeAnimation.js.map